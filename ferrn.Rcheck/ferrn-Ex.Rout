
R version 3.6.3 (2020-02-29) -- "Holding the Windsock"
Copyright (C) 2020 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "ferrn"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('ferrn')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("add_space")
> ### * add_space
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: add_space
> ### Title: A ggproto for drawing circle
> ### Aliases: add_space
> 
> ### ** Examples
> 
> library(ggplot2)
> space <- tibble::tibble(x0 = 0, y0 = 0, r = 5)
> ggplot() +
+   add_space(space) +
+   theme_void() +
+   theme(aspect.ratio = 1)
> 
> 
> 
> cleanEx()

detaching ‘package:ggplot2’

> nameEx("add_start")
> ### * add_start
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: add_start
> ### Title: A ggproto for drawing start points
> ### Aliases: add_start
> 
> ### ** Examples
> 
> library(ggplot2)
> # construct the space and start df for plotting
> space <- tibble::tibble(x0 = 0, y0 = 0, r = 5)
> start <- holes_1d_geo %>%
+   compute_pca() %>%
+   purrr::pluck("aug") %>%
+   clean_method() %>%
+   get_start()
> ggplot() +
+   add_space(dt = space) +
+   add_start(dt = start, start_color = info) +
+   theme_void() +
+   theme(aspect.ratio = 1)
> 
> 
> 
> cleanEx()

detaching ‘package:ggplot2’

> nameEx("bind_random")
> ### * bind_random
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bind_random
> ### Title: Bind random bases in the projection bases space
> ### Aliases: bind_random
> 
> ### ** Examples
> 
> bind_random(holes_1d_better) %>% tail(5)
# A tibble: 5 x 8
  basis          index_val info           method         alpha tries  loop    id
  <list>             <dbl> <chr>          <chr>          <dbl> <dbl> <dbl> <dbl>
1 <dbl[,1] [5 ×…        NA randomly_gene… randomly_gene…    NA    NA    NA     0
2 <dbl[,1] [5 ×…        NA randomly_gene… randomly_gene…    NA    NA    NA     0
3 <dbl[,1] [5 ×…        NA randomly_gene… randomly_gene…    NA    NA    NA     0
4 <dbl[,1] [5 ×…        NA randomly_gene… randomly_gene…    NA    NA    NA     0
5 <dbl[,1] [5 ×…        NA randomly_gene… randomly_gene…    NA    NA    NA     0
> 
> 
> 
> cleanEx()
> nameEx("bind_random_matrix")
> ### * bind_random_matrix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bind_random_matrix
> ### Title: Bind random bases in the projection bases space as a matrix
> ### Aliases: bind_random_matrix
> 
> ### ** Examples
> 
> data <- get_basis_matrix(holes_1d_geo)
> bind_random_matrix(data) %>% tail(5)
                 V1           V2         V3        V4         V5
[2912,] -0.11500792  0.108791393 -0.2119039 0.6421904  0.7194622
[2913,] -0.64030197  0.470754738  0.3598407 0.2095701  0.4415862
[2914,]  0.08192813 -0.400575298  0.2188422 0.2890079 -0.8375021
[2915,] -0.77069449 -0.002085302  0.2361071 0.5335136  0.2562077
[2916,] -0.53992262  0.069524169  0.4387449 0.1042930 -0.7073018
> 
> 
> 
> cleanEx()
> nameEx("bind_theoretical")
> ### * bind_theoretical
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bind_theoretical
> ### Title: Bind the theoretical best record
> ### Aliases: bind_theoretical
> 
> ### ** Examples
> 
> best <- matrix(c(0, 1, 0, 0, 0), nrow = 5)
> tail(holes_1d_better %>% bind_theoretical(best, tourr::holes(), raw_data = boa5), 1)
# A tibble: 1 x 8
  basis             index_val info        method alpha tries  loop    id
  <list>                <dbl> <chr>       <chr>  <dbl> <dbl> <dbl> <dbl>
1 <dbl[,1] [5 × 1]>     0.931 theoretical <NA>      NA    NA    NA     0
> 
> 
> 
> cleanEx()
> nameEx("data")
> ### * data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: holes_1d_geo
> ### Title: Simulated data
> ### Aliases: holes_1d_geo holes_1d_better holes_2d_better
> ###   holes_2d_better_max_tries boa boa5 boa6
> ### Keywords: datasets
> 
> ### ** Examples
> 
> library(ggplot2)
> library(tidyr)
> library(dplyr)

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

> boa %>%
+   pivot_longer(cols = x1:x10, names_to = "var", values_to = "value") %>%
+   mutate(var = forcats::fct_relevel(as.factor(var), paste0("x", 1:10))) %>%
+   ggplot(aes(x = value)) +
+   geom_density() +
+   facet_wrap(vars(var))
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’, ‘package:tidyr’, ‘package:ggplot2’

> nameEx("explore_space_pca")
> ### * explore_space_pca
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: explore_space_pca
> ### Title: Plot the PCA projection of the projection bases space
> ### Aliases: explore_space_pca flip_sign compute_pca
> 
> ### ** Examples
> 
> dplyr::bind_rows(holes_1d_geo, holes_1d_better) %>%
+   bind_theoretical(matrix(c(0, 1, 0, 0, 0), nrow = 5),
+     index = tourr::holes(), raw_data = boa5
+   ) %>%
+   explore_space_pca(group = method, details = TRUE) +
+   scale_color_discrete_botanical()
signs in all the bases will be flipped in group search_geodesic 

Adding missing grouping variables: `method`
> dplyr::bind_rows(holes_1d_geo, holes_1d_better) %>%
+   flip_sign(group = method) %>%
+   str(max = 1)
signs in all the bases will be flipped in group search_geodesic 

List of 3
 $ basis: num [1:495, 1:5] -0.341 -0.338 -0.344 -0.335 -0.347 ...
  ..- attr(*, "dimnames")=List of 2
 $ flip : logi TRUE
 $ dt   : tibble [495 × 8] (S3: tbl_df/tbl/data.frame)
> dplyr::bind_rows(holes_1d_geo, holes_1d_better) %>% compute_pca(group = method)
signs in all the bases will be flipped in group search_geodesic 

$pca_summary
Standard deviations (1, .., p=5):
[1] 1.0433992 1.0155630 0.9888052 0.9850722 0.9653222

Rotation (n x k) = (5 x 5):
          PC1        PC2        PC3        PC4        PC5
V1  0.5494898 -0.2012644  0.5927758 0.12915854 -0.5380414
V2 -0.3674142  0.5045363  0.1443116 0.73291782 -0.2290317
V3 -0.4473056 -0.4083083  0.6605713 0.06397122  0.4390390
V4  0.1028552 -0.6665882 -0.4230460 0.60415355  0.0333405
V5  0.5936381  0.3063988  0.1116634 0.27758911  0.6813143

$aug
# A tibble: 2,995 x 14
   basis   index_val info    method alpha tries  loop    id row_num   PC1    PC2
   <list>      <dbl> <chr>   <chr>  <dbl> <dbl> <dbl> <dbl>   <int> <dbl>  <dbl>
 1 <dbl[,…     0.749 new_ba… PD       0.5     1     1     1       1 -1.83 -0.617
 2 <dbl[,…     0.749 direct… PD      NA       2     1     2       2 -1.84 -0.628
 3 <dbl[,…     0.749 direct… PD      NA       2     1     3       3 -1.83 -0.606
 4 <dbl[,…     0.749 direct… PD      NA       2     1     4       4 -1.83 -0.607
 5 <dbl[,…     0.749 direct… PD      NA       2     1     5       5 -1.83 -0.627
 6 <dbl[,…     0.749 direct… PD      NA       2     1     6       6 -1.83 -0.596
 7 <dbl[,…     0.749 direct… PD      NA       2     1     7       7 -1.83 -0.637
 8 <dbl[,…     0.749 direct… PD      NA       2     1     8       8 -1.82 -0.627
 9 <dbl[,…     0.749 direct… PD      NA       2     1     9       9 -1.84 -0.607
10 <dbl[,…     0.749 best_d… PD      NA       2     1    10      10 -1.83 -0.635
# … with 2,985 more rows, and 3 more variables: PC3 <dbl>, PC4 <dbl>, PC5 <dbl>

> 
> 
> 
> cleanEx()
> nameEx("explore_space_tour")
> ### * explore_space_tour
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: explore_space_tour
> ### Title: Plot the grand tour animation of the bases space in high
> ###   dimension
> ### Aliases: explore_space_tour prep_space_tour
> 
> ### ** Examples
> 
> explore_space_tour(dplyr::bind_rows(holes_1d_better, holes_1d_geo),
+   group = method, palette = botanical_palettes$fern[c(1, 6)]
+ )
map method to color
target_dist - cur_dist: 0 
generation:  dist =   1.767093 
Using half_range 0.56
target_dist - cur_dist: 1.767093 
> 
> 
> 
> cleanEx()
> nameEx("explore_trace")
> ### * explore_trace
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: explore_trace_interp
> ### Title: Plot the trace the search progression
> ### Aliases: explore_trace_interp
> 
> ### ** Examples
> 
> # Compare the trace of interpolated points in two algorithms
> holes_1d_better %>%
+   explore_trace_interp(interp_size = 2) +
+   scale_color_continuous_botanical(palette = "fern")
map id to the x-axis
map tries to color
> 
> 
> 
> cleanEx()
> nameEx("explore_trace_search")
> ### * explore_trace_search
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: explore_trace_search
> ### Title: Plot the count in each iteration
> ### Aliases: explore_trace_search
> 
> ### ** Examples
> 
> # Summary plots for search points in two algorithms
> library(patchwork)
> library(dplyr)

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

> library(ggplot2)
> p1 <- holes_1d_better %>% explore_trace_search() +
+   scale_color_continuous_botanical(palette = "fern")
map tries to the x-axis
map tries to color
> p2 <- holes_2d_better_max_tries %>% explore_trace_search() +
+   scale_color_continuous_botanical(palette = "daisy")
map tries to the x-axis
map tries to color
> p1 / p2
> 
> 
> 
> cleanEx()

detaching ‘package:ggplot2’, ‘package:dplyr’, ‘package:patchwork’

> nameEx("format_label")
> ### * format_label
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: format_label
> ### Title: Better label formatting to avoid overlapping
> ### Aliases: format_label
> 
> ### ** Examples
> 
> format_label(c(0.87, 0.87, 0.9, 0.93, 0.95), 0.01)
[1] 0.87 0.90 0.93 0.95
> format_label(c(0.87, 0.87, 0.9, 0.93, 0.95, 0.96, 0.96), 0.01)
[1] 0.87 0.90 0.93 0.95 0.96
> 
> 
> 
> cleanEx()
> nameEx("get_anchor")
> ### * get_anchor
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_anchor
> ### Title: Extract the anchor points on the geodesic path
> ### Aliases: get_anchor
> 
> ### ** Examples
> 
> holes_1d_better %>% get_anchor()
# A tibble: 5 x 8
  basis             index_val info      method        alpha tries  loop    id
  <list>                <dbl> <chr>     <chr>         <dbl> <dbl> <dbl> <int>
1 <dbl[,1] [5 × 1]>     0.749 new_basis search_better 0.5       1     1     1
2 <dbl[,1] [5 × 1]>     0.752 new_basis search_better 0.5       2     6     2
3 <dbl[,1] [5 × 1]>     0.798 new_basis search_better 0.495     3     1     3
4 <dbl[,1] [5 × 1]>     0.813 new_basis search_better 0.49      4     7     4
5 <dbl[,1] [5 × 1]>     0.904 new_basis search_better 0.485     5     3     5
> holes_1d_geo %>% get_anchor()
# A tibble: 34 x 8
   basis           index_val info          method        alpha tries  loop    id
   <list>              <dbl> <chr>         <chr>         <dbl> <dbl> <dbl> <int>
 1 <dbl[,1] [5 × …     0.749 new_basis     search_geode…   0.5     1     1     1
 2 <dbl[,1] [5 × …     0.753 best_line_se… search_geode…  NA       2     1     2
 3 <dbl[,1] [5 × …     0.793 best_line_se… search_geode…  NA       3     1     3
 4 <dbl[,1] [5 × …     0.805 best_line_se… search_geode…  NA       4     1     4
 5 <dbl[,1] [5 × …     0.836 best_line_se… search_geode…  NA       5     1     5
 6 <dbl[,1] [5 × …     0.890 best_line_se… search_geode…  NA       6     1     6
 7 <dbl[,1] [5 × …     0.917 best_line_se… search_geode…  NA       7     1     7
 8 <dbl[,1] [5 × …     0.929 best_line_se… search_geode…  NA       8     1     8
 9 <dbl[,1] [5 × …     0.929 best_line_se… search_geode…  NA       9     1     9
10 <dbl[,1] [5 × …     0.933 best_line_se… search_geode…  NA       9     2    10
# … with 24 more rows
> 
> 
> 
> cleanEx()
> nameEx("get_basis_matrix")
> ### * get_basis_matrix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_basis_matrix
> ### Title: Extract all the bases as a matrix
> ### Aliases: get_basis_matrix
> 
> ### ** Examples
> 
> head(get_basis_matrix(holes_1d_better), 5)
              V1         V2          V3        V4        V5
[1,]  0.34100587 -0.1129065 -0.14519958 0.0357833 0.9211969
[2,]  0.47021229  0.2323680  0.49786511 0.3133040 0.6155294
[3,] -0.07081708 -0.3776694 -0.10317006 0.3478981 0.8489250
[4,]  0.23230438 -0.2897560  0.18500055 0.5184984 0.7476699
[5,] -0.10216793  0.4893826 -0.08432954 0.1108271 0.8547937
> 
> 
> 
> cleanEx()
> nameEx("get_best")
> ### * get_best
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_best
> ### Title: Extract the record with the largest index value
> ### Aliases: get_best
> 
> ### ** Examples
> 
> dplyr::bind_rows(holes_1d_better, holes_1d_geo) %>% get_best(group = method)
# A tibble: 2 x 8
# Groups:   method [2]
  basis            index_val info         method         alpha tries  loop    id
  <list>               <dbl> <chr>        <chr>          <dbl> <dbl> <dbl> <int>
1 <dbl[,1] [5 × 1…     0.914 interpolati… search_better     NA     5     6    55
2 <dbl[,1] [5 × 1…     0.933 interpolati… search_geodes…    NA     9     3   152
> 
> 
> 
> cleanEx()
> nameEx("get_dir_search")
> ### * get_dir_search
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_dir_search
> ### Title: Extract directional search points during the optimisation
> ### Aliases: get_dir_search
> 
> ### ** Examples
> 
> holes_1d_geo %>%
+   compute_pca() %>%
+   purrr::pluck("aug") %>%
+   get_dir_search()
# A tibble: 330 x 16
   basis   index_val info    method alpha tries  loop    id row_num   PC1    PC2
   <list>      <dbl> <chr>   <chr>  <dbl> <dbl> <dbl> <dbl>   <int> <dbl>  <dbl>
 1 <dbl[,…     0.749 direct… PD        NA     2     1     2       2 -1.80 -0.776
 2 <dbl[,…     0.749 direct… PD        NA     2     1     3       3 -1.77 -0.601
 3 <dbl[,…     0.749 direct… PD        NA     2     1     4       4 -1.79 -0.632
 4 <dbl[,…     0.749 direct… PD        NA     2     1     5       5 -1.78 -0.745
 5 <dbl[,…     0.749 direct… PD        NA     2     1     6       6 -1.80 -0.562
 6 <dbl[,…     0.749 direct… PD        NA     2     1     7       7 -1.77 -0.815
 7 <dbl[,…     0.749 direct… PD        NA     2     1     8       8 -1.73 -0.732
 8 <dbl[,…     0.749 direct… PD        NA     2     1     9       9 -1.84 -0.644
 9 <dbl[,…     0.749 best_d… PD        NA     2     1    10      10 -1.78 -0.804
10 <dbl[,…     0.749 direct… PD        NA     2     1    11      11 -1.79 -0.573
# … with 320 more rows, and 5 more variables: PC3 <dbl>, PC4 <dbl>, PC5 <dbl>,
#   anchor_x <dbl>, anchor_y <dbl>
> 
> 
> 
> cleanEx()
> nameEx("get_interp")
> ### * get_interp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_interp
> ### Title: Extract interpolated records
> ### Aliases: get_interp
> 
> ### ** Examples
> 
> holes_1d_better %>%
+   get_interp() %>%
+   head()
# A tibble: 6 x 8
  basis             index_val info          method       alpha tries  loop    id
  <list>                <dbl> <chr>         <chr>        <dbl> <dbl> <dbl> <int>
1 <dbl[,1] [5 × 1]>     0.749 interpolation search_bett…    NA     2     1     1
2 <dbl[,1] [5 × 1]>     0.750 interpolation search_bett…    NA     2     2     2
3 <dbl[,1] [5 × 1]>     0.751 interpolation search_bett…    NA     2     3     3
4 <dbl[,1] [5 × 1]>     0.751 interpolation search_bett…    NA     2     4     4
5 <dbl[,1] [5 × 1]>     0.752 interpolation search_bett…    NA     2     5     5
6 <dbl[,1] [5 × 1]>     0.752 interpolation search_bett…    NA     2     6     6
> get_interp(dplyr::bind_rows(holes_1d_better, holes_1d_geo), group = method) %>% head()
# A tibble: 6 x 8
  basis             index_val info          method       alpha tries  loop    id
  <list>                <dbl> <chr>         <chr>        <dbl> <dbl> <dbl> <int>
1 <dbl[,1] [5 × 1]>     0.749 interpolation search_bett…    NA     2     1     1
2 <dbl[,1] [5 × 1]>     0.750 interpolation search_bett…    NA     2     2     2
3 <dbl[,1] [5 × 1]>     0.751 interpolation search_bett…    NA     2     3     3
4 <dbl[,1] [5 × 1]>     0.751 interpolation search_bett…    NA     2     4     4
5 <dbl[,1] [5 × 1]>     0.752 interpolation search_bett…    NA     2     5     5
6 <dbl[,1] [5 × 1]>     0.752 interpolation search_bett…    NA     2     6     6
> 
> 
> 
> cleanEx()
> nameEx("get_interp_last")
> ### * get_interp_last
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_interp_last
> ### Title: Extract the end point at each interpolation
> ### Aliases: get_interp_last
> 
> ### ** Examples
> 
> holes_1d_better %>% get_interp_last()
# A tibble: 4 x 8
  basis             index_val info          method       alpha tries  loop    id
  <list>                <dbl> <chr>         <chr>        <dbl> <dbl> <dbl> <int>
1 <dbl[,1] [5 × 1]>     0.753 interpolation search_bett…    NA     2     9     9
2 <dbl[,1] [5 × 1]>     0.798 interpolation search_bett…    NA     3    15    24
3 <dbl[,1] [5 × 1]>     0.866 interpolation search_bett…    NA     4     7    31
4 <dbl[,1] [5 × 1]>     0.914 interpolation search_bett…    NA     5     6    37
> get_interp_last(dplyr::bind_rows(holes_1d_better, holes_1d_geo), group = method)
# A tibble: 12 x 8
   basis            index_val info         method        alpha tries  loop    id
   <list>               <dbl> <chr>        <chr>         <dbl> <dbl> <dbl> <int>
 1 <dbl[,1] [5 × 1…     0.753 interpolati… search_better    NA     2     9     9
 2 <dbl[,1] [5 × 1…     0.798 interpolati… search_better    NA     3    15    24
 3 <dbl[,1] [5 × 1…     0.866 interpolati… search_better    NA     4     7    31
 4 <dbl[,1] [5 × 1…     0.914 interpolati… search_better    NA     5     6    37
 5 <dbl[,1] [5 × 1…     0.753 interpolati… search_geode…    NA     2     7     7
 6 <dbl[,1] [5 × 1…     0.793 interpolati… search_geode…    NA     3    11    18
 7 <dbl[,1] [5 × 1…     0.805 interpolati… search_geode…    NA     4     7    25
 8 <dbl[,1] [5 × 1…     0.836 interpolati… search_geode…    NA     5     8    33
 9 <dbl[,1] [5 × 1…     0.890 interpolati… search_geode…    NA     6     7    40
10 <dbl[,1] [5 × 1…     0.917 interpolati… search_geode…    NA     7     5    45
11 <dbl[,1] [5 × 1…     0.929 interpolati… search_geode…    NA     8     4    49
12 <dbl[,1] [5 × 1…     0.933 interpolati… search_geode…    NA     9     3    52
> 
> 
> 
> cleanEx()
> nameEx("get_interrupt")
> ### * get_interrupt
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_interrupt
> ### Title: Extract the end point of the interpolation and the target point
> ###   in the iteration when an interruption happens
> ### Aliases: get_interrupt
> 
> ### ** Examples
> 
> holes_1d_better %>% get_interrupt()
# A tibble: 6 x 8
  basis             index_val info         method        alpha tries  loop id   
  <list>                <dbl> <chr>        <chr>         <dbl> <dbl> <dbl> <chr>
1 <dbl[,1] [5 × 1]>     0.752 new_basis    search_bett…  0.5       2     6 2    
2 <dbl[,1] [5 × 1]>     0.813 new_basis    search_bett…  0.49      4     7 4    
3 <dbl[,1] [5 × 1]>     0.904 new_basis    search_bett…  0.485     5     3 5    
4 <dbl[,1] [5 × 1]>     0.753 interpolati… search_bett… NA         2     9 2    
5 <dbl[,1] [5 × 1]>     0.866 interpolati… search_bett… NA         4     7 4    
6 <dbl[,1] [5 × 1]>     0.914 interpolati… search_bett… NA         5     6 5    
> holes_1d_geo %>% get_interrupt()
interrupt is only implemented in simulated annealing methods
NULL
> 
> 
> 
> cleanEx()
> nameEx("get_search")
> ### * get_search
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_search
> ### Title: Extract search points during the optimisation
> ### Aliases: get_search
> 
> ### ** Examples
> 
> holes_1d_better %>% get_search()
# A tibble: 37 x 8
   basis             index_val info         method       alpha tries  loop    id
   <list>                <dbl> <chr>        <chr>        <dbl> <dbl> <dbl> <int>
 1 <dbl[,1] [5 × 1]>     0.730 random_sear… search_bett…  0.5      2     1     2
 2 <dbl[,1] [5 × 1]>     0.743 random_sear… search_bett…  0.5      2     2     3
 3 <dbl[,1] [5 × 1]>     0.736 random_sear… search_bett…  0.5      2     3     4
 4 <dbl[,1] [5 × 1]>     0.747 random_sear… search_bett…  0.5      2     4     5
 5 <dbl[,1] [5 × 1]>     0.725 random_sear… search_bett…  0.5      2     5     6
 6 <dbl[,1] [5 × 1]>     0.769 random_sear… search_bett…  0.49     4     1    33
 7 <dbl[,1] [5 × 1]>     0.754 random_sear… search_bett…  0.49     4     2    34
 8 <dbl[,1] [5 × 1]>     0.725 random_sear… search_bett…  0.49     4     3    35
 9 <dbl[,1] [5 × 1]>     0.766 random_sear… search_bett…  0.49     4     4    36
10 <dbl[,1] [5 × 1]>     0.736 random_sear… search_bett…  0.49     4     5    37
# … with 27 more rows
> holes_1d_geo %>% get_search()
# A tibble: 363 x 8
   basis          index_val info            method       alpha tries  loop    id
   <list>             <dbl> <chr>           <chr>        <dbl> <dbl> <dbl> <int>
 1 <dbl[,1] [5 ×…     0.749 direction_sear… search_geod…    NA     2     1     2
 2 <dbl[,1] [5 ×…     0.749 direction_sear… search_geod…    NA     2     1     3
 3 <dbl[,1] [5 ×…     0.749 direction_sear… search_geod…    NA     2     1     4
 4 <dbl[,1] [5 ×…     0.749 direction_sear… search_geod…    NA     2     1     5
 5 <dbl[,1] [5 ×…     0.749 direction_sear… search_geod…    NA     2     1     6
 6 <dbl[,1] [5 ×…     0.749 direction_sear… search_geod…    NA     2     1     7
 7 <dbl[,1] [5 ×…     0.749 direction_sear… search_geod…    NA     2     1     8
 8 <dbl[,1] [5 ×…     0.749 direction_sear… search_geod…    NA     2     1     9
 9 <dbl[,1] [5 ×…     0.749 best_direction… search_geod…    NA     2     1    10
10 <dbl[,1] [5 ×…     0.749 direction_sear… search_geod…    NA     2     1    11
# … with 353 more rows
> 
> 
> 
> cleanEx()
> nameEx("get_search_count")
> ### * get_search_count
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_search_count
> ### Title: Extract the count in each iteration
> ### Aliases: get_search_count
> 
> ### ** Examples
> 
> get_search_count(holes_1d_better)
map tries to the x-axis
# A tibble: 6 x 2
  tries     n
* <dbl> <int>
1     1     1
2     2     6
3     3     1
4     4     7
5     5     3
6     6    24
> get_search_count(dplyr::bind_rows(holes_1d_better, holes_1d_geo), group = method)
map tries to the x-axis
# A tibble: 16 x 3
# Groups:   tries [10]
   tries method              n
   <dbl> <chr>           <int>
 1     1 search_better       1
 2     2 search_better       6
 3     3 search_better       1
 4     4 search_better       7
 5     5 search_better       3
 6     6 search_better      24
 7     1 search_geodesic     1
 8     2 search_geodesic    11
 9     3 search_geodesic    11
10     4 search_geodesic    11
11     5 search_geodesic    11
12     6 search_geodesic    11
13     7 search_geodesic    11
14     8 search_geodesic    11
15     9 search_geodesic    22
16    10 search_geodesic   264
> 
> 
> 
> cleanEx()
> nameEx("get_start")
> ### * get_start
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_start
> ### Title: Extract the starting records
> ### Aliases: get_start
> 
> ### ** Examples
> 
> holes_1d_better %>% get_start()
# A tibble: 1 x 8
  basis             index_val info      method        alpha tries  loop    id
  <list>                <dbl> <chr>     <chr>         <dbl> <dbl> <dbl> <int>
1 <dbl[,1] [5 × 1]>     0.749 new_basis search_better   0.5     1     1     1
> 
> 
> 
> cleanEx()
> nameEx("get_theo")
> ### * get_theo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_theo
> ### Title: Extract the theoretical best basis, if applicable
> ### Aliases: get_theo
> 
> ### ** Examples
> 
> best <- matrix(c(0, 1, 0, 0, 0), nrow = 5)
> holes_1d_better %>%
+   bind_theoretical(best, tourr::holes(), raw_data = boa5) %>%
+   get_theo()
# A tibble: 1 x 8
  basis             index_val info        method alpha tries  loop    id
  <list>                <dbl> <chr>       <chr>  <dbl> <dbl> <dbl> <dbl>
1 <dbl[,1] [5 × 1]>     0.931 theoretical <NA>      NA    NA    NA     0
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  4.359 0.107 4.603 0.002 0.003 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
